struct Friend jj;

class 란 Object를 사용하기 위한 문법
Object란  묶여 있는 개념
Friend jj{"jj","updtown",2,30,10}; 메모리를 가지게 해주는 것을 instanciation 부름{}안에 들어있는것
jj를 instance라고 부름

친구들이 여러명이다
vector로 선언 하면된다.
vector<Friend> my_friend;
---------------------------------------------------------------------------------------------------------
캡슐화
private 과 public
외부 에서 접근 불가 / 누구나 접근 가능

private은 접근 할려면 접근 함수를 만들어 줘야함 

public으로 나를 통해서 가라
void setDate()함수를 정의 해야함

반환형 &getDay() 함수를 만들어 출력할수있게한다.
레퍼렌스를 사용한 이유는 값을 복사하는 것을 막기 위해 또 변환을 막기위해 const를 사용함
---------------------------------------------------------------------------------------------------------
생성자
class a 를 만들고 private으로 멤버를 정의를 하고
그냥 main에서 출력하면 초기화 되지 않은 값이 나온다.
이러한 문제를 해결하기 위해서
생성자를 선언하는 것이 하나의 방법이다.
a() 선언 하고 멤버를 초기화 해주면 된다.

실행 순서
main에서 오브젝트와 인스턴스를 선언하면 바로 생성자가 실행이된다.
//주의 -> 생성자도 함수인데 왜 ()를 안해주나 파라미터가 적혀있지 않으면 그냥 사용해야한다. 한계점이있다.
디폴트 생성자는 파라미터가 여러개인 함수나 하나도 없는 함수 인지 컴퓨터가 알수 없기에 조심해서 사용
클래스 안에 멤버 클래스를 사용되면 멤버 클래스가 먼저 선언이 된다.

---------------------------------------------------------------------------------------------------------
이니셜라이져 리스트
생성자()
: 멤버 변수(1)
로 생성자를 초기화 하는 방법이다. 멤버 클래스도 사용 가능

만약 멤버에서 초기화 하는 거랑 생성자 초기화를 하면 생성자 초기화가 우선순위가 높다.
그리고 이니셜라이져 리스트에서 초기화를 하고 함수 안에서 초기화 해주면 안에서 사용되게 사용된다.
---------------------------------------------------------------------------------------------------------
위임 생성자
//주의 -> 파라미터에서 디폴트 값을 넣어 줄때 맨 오른쪽 부터 왼쪽으로 채워나가야한다. 중간부터 x

방법 1.
생성자(이름)
: 생성자(학번,이름)

생성자(학번,이름)
초기화
위임 생성자 방식이다 이름만 가지고 있는 생성자를 먼저 들어가지만 둘다 가지고 있는 생성자가 있어야함

방법 2. 이방법을 조금 더 선호하는 방식이다.
생성자 (이름)
{
	init(0,이름); 으로 초기화 해주는 방식이 있다.
}
생성자(학번,이름)
{
	init(학번,이름);
}
void init 모든 것을 초기화 해주는 함수를 만들어
---------------------------------------------------------------------------------------------------------
소멸자
소멸자는 파라미터가 없다.
생성자에서 동적 할당을 해주고
소멸자에서 delete를 사용해서 메모리 릭을 막아줌
---------------------------------------------------------------------------------------------------------
this 포인터와 연쇄 호출
this -> 화살표는 클래스나 스트럭트가 포인터일 경우에 멤버 셀렉션 오퍼레이터

object 인스턴스
개념상 object::함수(&인스턴스, value) 이렇게 이해하면된다

object 인스턴스1, 인스턴스2
인스턴스 마다 주소가 다른다 그래서 this ->함수는
현재의 주소의 함수를 사용하겠다는 말이다.

this 포인터 사용 예제
class Calc
{
멤버 변수

생성자 (const int & a);
Calc& 함수(멤버 변수 += a; return *this;)를 선언하면
}
main에선 cal.add(10).sub(1).mult(2);라고 하면 리턴 값이 자기 자신이기 때문에 연속을 사용가능하다.
---------------------------------------------------------------------------------------------------------
클래스 코드와 헤더 파일

헤더 파일에는 클래스 선언
cpp파일에는 정의 
헤더파일에서 using namespace std; 선언하면 전부 영향을 받아 안좋다.
main 파일에서 #include <헤더파일 선언> 을 하면 할 수 있다.

클래스.cpp 파일에서 정의 할때
object::함수(파라미터) 를 해서 접근을 해야 오류가 없다
---------------------------------------------------------------------------------------------------------
클래스와 const

const는 상수로 변환 하는 작업이다 상수란 변하지 않는 수

클래스 인스턴스;
인스턴스.setvalue(3);을 하면 값을 바꿀수 있다.
하지만 const 클래스 인스턴스; 로 선언하면 setvalue를 사용할 수 없다.
그리고 값을 바꾸지 않아도 getvalue도 안된다.
const 클래스 인스턴스는 값을 바꾸는 것이 중점이 아니라 함수도 const인지 아닌지를 판별하는게 중점
int getvalue() const 선언하면 사용이 가능하다.
setvalue 함수는 성립자체가 안됨 기능이 값을 바꾸는 거라 안됨

클래스 인스턴스;
인스턴스 주소와 함수(인스턴스)의 주소는 다른데 왜 생성자는 한번만 호출이 되나?
주소가 다른 이유는 값을 복사해서 사용하기 때문이다.
복사 생성자가 숨어 있기 때문이다 정의를 안해도 있다.

함수(파라미터)
함수(인스턴스 변수)를 기본적으로 사용하지만 
함수(const 인스턴스 &변수) 
주소도 같고 복사도 안하고 이렇게 사용하면 최적화 하기 좋다.

하나는 const를 사용하고 하나는 그냥 사용한다
1. const 반환형& getValue() const {return m_valuel;}

2. string& getValue() {return m_value;}

main()
클래스 인스턴스
인스턴스.getValue()

const 클래스 인스턴스
인스턴스.getValue()
를 사용하면  const를 사용하면 클래스에서 const 버전인 getValue를 사용하고 
nonconst버전은 논getValue를 사용함
---------------------------------------------------------------------------------------------------------
정적 멤버 변수

클래스
static int 멤버 변수 하고 일반적인 선언을 하면 에러가 남
기본 원리는 static 멤버 변수는 이니셜라이져를 할 수 없음
이러한 방식을 하지 않고
int 클래스::멤버변수 = 1; 이라고 작성한다. 이렇게 사용하면 st1이랑 st2 주소가 같다

주의 // cpp파일 안에서 정의 하는 것이 좋음 h에서 선언하면 오류가 생길일이 있다.

static const int 멤버변수 = 1 정의는 가능하고 반드시 바로 초기화 해줘야 한다.
---------------------------------------------------------------------------------------------------------
constexpr은 컴파일 타임에 결정되야 하는 상수
연산자 우선순위와 결합법칙
 ---------------------------------------------------------------------------------------------------------
정적 멤버 함수                  잘 이해 못함
static 자료형 함수()

main()
클래스::함수();
static 함수 안에서는 this포인터를 사용을 못한다. 
멤버 변수도 static이여지 this 사용이 가능

클래스 안에 클래스 사용 가능
 ---------------------------------------------------------------------------------------------------------
친구 함수와 클래스

클래스가 어떤 함수가 클래스를 접근하고 인스턴스.멤버변수를 출력하고 싶은데
멤버 변수가 private이기 때문에 사용할 수 없다. 이때 해결방법이
friend를 사용하면 문제가 해결된다.
friend 자료형 함수(클래스& 파라미터)로 사용한다.

보너스 ) 함수(클래스 2개)를 사용하고 싶으면 둘다 friend를 하고 전방 선언을 해주면 된다.
클래스 안에서도 파라미터를 맞춰줘야 한다.

통째로 다 넘겨주기 그렇다 하면 함수 하나에만
friend 다른 클래스:: 함수(파라미터)이렇게 사용해주면 된다.
그래도 오류가 있으면 선언은 하되 정의는 나중에 하면 문제가 해결이 된다.
 ---------------------------------------------------------------------------------------------------------
익명 객체

클래스 인스턴스;
인스턴스.함수 이렇게 사용하기 번거러우면
클래스(1).함수 이렇게도 사용이 가능하다.
한번만 하고 사라지는 특징이 있다.
 ---------------------------------------------------------------------------------------------------------
클래스 안에 포함된 자료형

innerclass 클래스 안에서 데이터 타임을 정의 할 수 있다.
사용할때
클래스::innerclass의 클래스::이널클래스 멤버변수 로 사용하면된다.
 ---------------------------------------------------------------------------------------------------------
산술 연산자 오버로딩 하기

클래스 인스턴스1와 클래스 인스턴스2를 더해주고 싶을 때 함수를 만들어 하는 방법이 있다.
friend 클래스 operator + (const 클래스 &c1,const 클래스 c2);
return 클래스(c1.클래스 + c2.클래스)로 사용하면 됨
 ---------------------------------------------------------------------------------------------------------
입출력 연산자 오버로딩

장점 코드가 간편해짐 클래스 인스턴스만 사용해서 출력이 가능하다.

friend ostream& operator << (ostream &out, const 클래스 &파라미터)
	out << 멤버변수 << endl; 가 가능
return out 을 추가하는 이유는 체이닝을 하기위해서 p1 << p2 이렇게 사용할 수 있다.
파일 출력이 이렇게 사용하기 때문에 사용하면 좋다.

출력은 istream이다 
 ---------------------------------------------------------------------------------------------------------
단항 연산자

클래스 operator - () const
{
	return 클래스(-멤버 변수);
}

클래스 operator ! () const
{
	return (멤버 변수== 0)?true:false; 
}
 ---------------------------------------------------------------------------------------------------------
비교 연산자 오버로딩 

friend bool operator == (const 클래스& 인스턴스,const 클래스& 인스턴스)
{
	return 인스턴스 == 인스턴스;
}

friend bool operator <//오른쪽이 더 크다로 작성해야한다 안그러면 에러남 
 ---------------------------------------------------------------------------------------------------------
증감 연산자 오버로딩

pre
클래스& operator ++ ()
{
	++멤버변수
	return *this;
}

post는()에 int 하고 
{
	클래스 참조변수(멤버변수);
	++(*this);
	return 참조변수;
}
 ---------------------------------------------------------------------------------------------------------
첨자 연산자 오버로딩 []

int & operator [] (const int index)
{
	//안에 음수가 들어갈 이유가 없으니 assert를 사용해서 크기를 정해줌
	return 멤버변수[index]; 
}

클래스 *list = new 클래스
(*list)[]를 하고 첨자 연산자 오버로딩을 해야한다.
 ---------------------------------------------------------------------------------------------------------
괄호 연산자 오버로딩
int operator() (int i)
{
	return (멤버면수 += i); //멤버 변수 = 0;
}
 ---------------------------------------------------------------------------------------------------------
형변환을 오버로딩
static_case 명시적 캐스팅
강제 캐스팅이랑 차이점이 조금더 안전하다. //컴파일을 더 여러번 해서 확인한다.

operator 클래스(const int & 파라미터)
{
	return 클래스(파라미터);
}

---------------------------------------------------------------------------------------------------------
복사 생성자, 복사 초기화 반환값 최적화

복사 생성자는 자기 자신을 복사하는 생성자를 말함
클래스 (const 클래스 & 파라미터)

사용법
클래스 인스턴스(3,5)
클래스 인스턴스(인스턴스)

사용하고 싶지 않을 때 private에서 사용하면된다.

주소가 같은면 복사 생성자를 호출을 안함 다르면 호출함
---------------------------------------------------------------------------------------------------------
변환 생성자 explicit, delete

클래스  인스턴스(값)을 넣으면 그 값이 알아서 초기화가 되어 사용을 하는데
explicit 클래스로 선언을 하면 명확히 넣으라고 알려주는 언어 이다.

---------------------------------------------------------------------------------------------------------
대입 연산자 오버로딩 깊은 복사 얕은 복사

클래스 인스턴스2 = 인스턴스1; 랑
인스턴스2 = 인스턴스1 이랑은 다른다
1번째는 복사 생성자를 하는 것이고 2번째는 대입 연사자 오버로딩이다.

얕은 복사를 할 때 같은 주소를 동적 할당 할때 같은 데이터를 가지고 있어 괄호를 벗어나면 값이 사라진다.
하나의 힙에 생성된 new 가 있는데 같은 주소를 가리키면서 괄호를 나가면 다 같이 삭제가 됨

그냥 복사 생성자를 사용하면 디폴디 복사 생성자가 선언이 되어
얕은 복사가 되어서 괄호를 나가면 초기에 선언한 생성자도 삭제가 된다.
********주소가 같다

하지만 깊은 복사 생성자를 따로 선언을 하면 주소가 다르기에 괄호를 나가도 문제가 없다
********주소가 다르다

---------------------------------------------------------------------------------------------------------
전역 변수, 정적 변수, 내부 연결, 외부 연결 
Globla Variable, Static Variable, Internal Linkage, External Linkage

간단하게 설명 여러 cpp파일에서 접근을 해서 작업할 때 접근이 가능한지

전역 변수 
로컬은 지역변수
만약 덮어 씌우면 사용할 수 없는지 ::을 사용하면 사용할 수 있다.
적게 사용해라

정적 변수
정적이랑 전역이랑 차이점 만든 사람의 시점에서 봐야한다.
메모리 관점이다 static을 사용하면 정적 메모리에서 관리한다.
정의가 되고 작업 하고 다시 같은 함수를 접근하면 static을 만나면 어디서 한번 실행 했다는것이 남아 있어
사용된 변수를 재사용한다 그렇기 떄문에 대입을 하지 않음
그리고 선언을 하면 바로 초기화를 해야한다. 

링킹에이지
로컬은 링킹이 될 필요가 없다

내부 연결은 
개별 cpp 파일안에서만 전역변수를 연결된 것을 말함
static 전역 변수는 다른 파일에서도 접근이 불가능

외부 연결
만약 다른 cpp에서 함수를 선언하고 maincpp에서 사용하고 싶으면 forward declaration: 전방선어
main 위에 함수를 선언 해주면 된다. 앞에 extern 붙여 주면 더욱 좋다 없어도 되지만 생략 되어있음
동일한 헤더 파일에서 같은 값을 가지고 왔어도 주소는 다르다.
주소가 같아 질려면 헤더에서는 선언만 하고 같은cpp를 만들어 정의를 해서 사용하면 주소가 같다.

정리
int g_x; // external linkage
static int g_x;// internal linkage
const int g_x;// 이거는 안됨 값을 초기화 해주지 않아서

extern int g_z;
extern const int g_z;//한군데 에서만 초기화 해줘야함

int g_y(1);
static int g_y(1); // internal linkage
const int g_y(1); // 같은 파일에서 만 접근

extern const int g_w(1); // 다른 파일에서 접근 가능한 상수

---------------------------------------------------------------------------------------------------------
비트 마스크

---------------------------------------------------------------------------------------------------------
Using 문과 모호성

이름이 같은 함수를 사용하는데 어떤 함수를 사용할 것인지 정해주는 것을 의미한다
---------------------------------------------------------------------------------------------------------
Auto 키워드와 자료형 추론

상황에 따라서 형추론을 하여 자료형을 변환하는 것이 auto이다.
초기화는 꼭 해줘야 한다.
함수도 auto를 사용할 수 있다.
파라미터는 auto를 사용할 수 없다. 파라미터는 template을 하면된다.
---------------------------------------------------------------------------------------------------------
형변환
---------------------------------------------------------------------------------------------------------
string 

띄어 쓰기 입력 받을 떄에는 std:;getline(std::cin , 변수);
std::cin.ignore(32767,'\n'); 대신에  
string은 + 까지 가능 하다
---------------------------------------------------------------------------------------------------------
열거형

enum 이름 선언을 하고 안에 내용을 문자로 선언을 하면 됨
int 멤버변수 = enum 변수 는 사용이 가능하지만 
enum 인스턴스 = 3 은 사용할 수 없음
하지만 static_cast<Color>(3) 은 사용할 수 있다.
string str
getline(cin, str);
if(str == "COLOR_BALCK") //가능
---------------------------------------------------------------------------------------------------------
영역 제한 열거형 (Enum Class)

enum class Color
enum class Fruit

Color color = Color::RED;
Fruit fruit = Fruit::BANANA;
enum class를 추가하면 명시적으로 사용해야 사용할 수 있고
if(color == fruit)을 사용할 수 없다 사용할려면 static_cast<int>을 사용해야한다.

하지만 하나의 클래스에서 비교 연산을 가능하다
Color color1 = Color::BLUE;
Color color2 = Color::BLUE;
if(color1 == color2)는 사용가 가능하다.
---------------------------------------------------------------------------------------------------------
자료형에게 가명 붙여주기 Type aliases

typedef double distance_t;
double 멤버변수;
distance 멤버변수;
를 사용해도 둘다 내용이 같다.
사용하는 이유는 복잡한 자료형을 간단하게 사용하기 위해서
최근에는 using 을 사용한다.
using 멤버변수 =  자료형; 이렇게 사용한다.
---------------------------------------------------------------------------------------------------------
구조체 struct

사용하는 이유
함수에 파라미터에 값을 넣어주기 힘들고 여려개의 함수를 만들기 힘들기 때문이다.
구조체 초기화 해줄때 유니폼 이니셜라이져를 사용함
구조체 파라미터{초기화};
파라미터를 하나만 사용하면 되기 때문에 좋다.

구조체 안에 함수를 넣어서 파라미터를 넣어주지 않아도 되는 방법이 있다.

구조체 getMe() 에 정의를 하고 return me;를 할수 있다.
구조체 인스턴스 = getMe();
인스턴스.함수();로 사용할 수 있다.
---------------------------------------------------------------------------------------------------------
정적 다차원 배열

배열[1][2]로 정의 그리고 2번째 배열은 꼭 정의 해줘야 함 
초기화는 대입을 해도 되고 {{1,2,3,4,5}} 로 해도 된다 {}하나에 row하나 이다.
주소는 일차원 처럼 주소값이 증가한다. int형이면 4byt만큼 증가 다음 row가 증가 해도 4씩증가
---------------------------------------------------------------------------------------------------------
strcpy 카피
strcat 이어쓰기
strcmp 글자가 같은가 같은면 0을 리턴 다르면 -1 리턴 (주의******)
---------------------------------------------------------------------------------------------------------
포인터의 기본적인 사용법

주소는 다 같다 주소의 크기는 4바이트 (집이 더크다고 주소가 길어 지지는 않자나)
---------------------------------------------------------------------------------------------------------
포인터 연산과 배열 인덱싱

int value =7;
int *ptr = &value;
cout << prt << endl;
주소를 출력하는 것이다 외우자

char name[] = "Jack jack";
const int n_name = sizeof(name)/sizeof(char);

for(int i=0; i< n_name;i++)
{
	cout << *(name + i);
	이름 배열의 순서대로 출력 name+0 = J 증가 할 때마다 다음 글자
}
char *ptr = name;
포인터와 배열은 같이 사용 되서 가능하다
char *name = "Jack jack"은 안된다 이유는 포인터는 주소를 가리키기 때문에 안된다
하지만  const를 붙혀 사용 하면 특별히 사용할 수 있다.

const char *name = "Jack jack";
const char *name2 = "Jack jack";
둘이 가리키는 주소가 같아 하지만 들어가는 글자가 하나라도 다르면 주소가 틀려 진다***
---------------------------------------------------------------------------------------------------------
메모리 동적 할당 new와 delete

배열은 정적 배열이라 스택에 들어가고
동적 배열은 힙이다.
new int는 메모리를 받고 주소를 알려줘서 주소로 받아야 한다.
int *ptr = new int;
delete[] ptr;
---------------------------------------------------------------------------------------------------------
동적 할당 배열

cin >> length;
int *array = new int[length];
초기화는 마지막에 ()추가 0으로 초기화 됨
{11,22,33,44,55};이렇게도 초기화 가능 많이는 되지만 적게 실행하면 문제가 됨


















































