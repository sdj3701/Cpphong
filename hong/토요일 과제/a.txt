1. kernel - Process - Thread
- kernel
영문
커널은 컴퓨터 운영체제의 핵심에 있는 컴퓨터 프로그램이며 일반적으로 시스템의 모든 것을 완벽하게 제어합니다.
항상 메모리에 상주하는 운영 체제 코드의 일부이며 하드웨어와 소프트웨어 구성요소 간의 상호 작용응 용이하게 합니다.
전체 커널은 장치 드라이버를 통해 모든 하드웨어 리소스를 제어하고 이런한 리소스와 관련된 프로세스 간의 충돌을 중재하며 cpu및 캐시 사용
파일 시스템 및 네트워크 소켓과 같은 공통 리소스의 활용을 최적화합니다.

한
커널은 컴퓨터 운영체제의 핵심이 되는 컴퓨터 프로그램으로, 시스템의 모든 것을 완전히 통제
커널은 운영 체제의 핵심 부분이므로, 커널의 역할 역시 운영 체제의 핵심 역할

- 보안
커널은 컴퓨터 하드웨어와 프로세스의 보안을 책임진다.
- 자원관리
한정된 시스템 자원을 효율적으로 관리하여 프로그램의 실행을 원활하게 한다.
- 추상화
같은 종류의 부품에 대해 다양한 하드웨어를 설계할 수 있기 때문에 하드웨어에 직접 접근하는 것은 문제를 매우 복잡하게 만들수 있다.
일반적으로 커널은 운영 체제의 복잡한 내부를 감추고 깔금하고 일관성 있는 인터페이스를 하드웨어에 제공하기 위해 몇 가지 하드웨어 추상화 들을 구현한다
---------------------------------------------강의---------------------------------------------------------------
kernel
운영체제의 핵심 서비스를 담당하는 부분을 커널이라고 한다
(유저 인터페이스는 커널에 속하지 않음) -사용자와 프로그램의 통로이기 때문에

이중 모드 
- cpu가 명령어를 실행하는 모드를 크게 사용자 모드와 커널 모드로 구분하는 방식
- 사용자 모드
1. 운영체제 서비슬을 제공받을 수 없는 실행 모드
2. 커널 영역의 코드를 실행할 수 없는 실행 모드
3. 자원 접근 불가
- 커널 모드
1. 운영체제의 서비스를 제공받을 수 있는 실행 모드
2. 자원 접근을 비롯한 모든 명령어 실행 가능

시스템 호출
- 커널 모드로 전환하여 실행 하기 위해 호출
- 일종의 소프트웨어 인터럽트
1. 시스템 호출이 처리되는 방식은 하드웨어 인터럽트 처리 방식과 유사

---------------------------------------------강의---------------------------------------------------------------


---------------------------------------------강의---------------------------------------------------------------
Process 
실행 중인 프로세스
(프로그램)보조 기억장치에 메모리에 실행하도록 하는 것을 프로세스라고 함 -이러한 일을 프로세스 생선한다
종류
포그라운드 프로세스
- 사용자가 볼 수 있는 공간에서 실행되는 프로세스 (웹, 게임 기타 등등)
백그라운드 프로세스
- 사용자가 볼 수 없는 공간에서 실해되는 프로세스
1. 사용자와 직접 상호작용이 가능한 백그라운드 프로세스
2. 사용자와 상호작용하지 않고 그저 정해진 일만 수해하는 프로세스
- 데몬, 서비스라고 부른다

프로세스들은 돌아가며 한정된 시간 만큼만 cpu 이용
- 타이머 인터럽트가 발생하면 차례 양보 (타이머 인터럽트 : 클럭신호를 발생시키는 장치에 의해서 주기적으로 발생하는 하드웨어 인터럽트)

이렇게 빠르게 번갈아 수행되는 프로세스들을 관리해야함 이를 위해서 사용하는 자료구조가 프로세스 제어 블록이라고 함pcb 
- 프로세스 관련 정보를 저장하는 자료 구조
- 마치 상품에 달린 태그와 같은 정보
- 프로세스 생성 시 커널 영역에 생성, 종료 시 폐기
 
pcb에 담기는 대표적인 정보
프로세스 ID
- 특정 프로세스를 식별하기 위해 부여하는 고유한 번호 (ex) 학교의 학번, 회사의 사번)
레지스터 값 
- 프로세스는 자신의 실행 차례가 오면 이전까지 사용한 레지스터 중간 값을 모두 복원 -> 실행 재게
프로세스 상태
- 생성 상태, 대기 상태 ,준비 상태 ,실행 상태
- 입출력 장치를 사용하기 위해서 기다리는 상태 , cpu를 사용하기 위해 기다리는 상태 기타 등등

= 생성 상태
- 이제 막 메모리에 적재되어 PCB를 할당 받은 상태
- 준비가 완료되었다면 준비 상태
= 준비상태
- 당장이라도 cpu를 할당 받아 실행할 수 있지만 자신의 차례가 아니기에 기다리는 상태
- 자신의 차례가 된다면 실행 상태로(= 디스패치)
= 실행 상태
- cpu를 할당 받아 실행 중인 상태
- 할당된 시간 모두 사용시(타이머 인터럽트 발생 시)준비 상태로
- 실행 도중 입출력 장치를 사용하면 입출력 작업이 끝날 때까지 대기 상태로
= 대기 상태
- 프로세스가 실행 도중 입출력장치를 사용하는 경우
- 입출력 작업은 cpu에 비해 느리기에 이 경우 대기 상태로 접어듬
- 입출력 작업이 끝나면 (입출력 완료 인터럽트를 받으면) 준비 상태로
= 종료 상태 
- 프로세스가 종료된 상태
-pcb, 프로세스의 메모리 영역 정리

cpu 스케줄링 정보
- 프로세스가 언제, 어떤 순서로 cpu를 할당받을지에 대한 정보
메모리 정보
- 프로세스가 어느 주소에 저장되어 있는지에 대한 정보
사용한 파일과 입출력장치 정보
- 할당된 입출력장치, 사용 중인 파일 정보

문맥 교환 (context switch)
- 한 프로세스(a)에서 다른 프로세스로(b) 실행 순서가 넘어가면? 어떤 작업을 이루어 질까?
- 기존에 실행된 프로세스 a는 지금까지의 중간 정보를 백업 (이러한 중간 정보를 == 문맥이라하고 실행 문맥을 백업해두면 언제든지 해당 프로세스의 실행을 재개할 수 있다)
- 뒤이어 실행할 프로세스b 의 문맥을 복구하며 자연스럽게 실행 중인 프로세스가 바뀜
결론 : 이처럼 기존의 실행 중인 프로세스 문맥을 백업하고 새로운 프로세스 실행을 위해 문맥을 복구하는 과정을 문맥 교환(여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리)이라 한다

프로세스의 메모리 영역
- 크게 코드영역(=텍스트 영역), 데이터 영역,힙 영역, 스택 영역 등이 사용자 영역이라고 불림

코드영역
- 실핼할 수 있는 코드, 기계어로 이루어진 명령어 저장
- 데이터가 아닌 cpu가 실행할 명령어가 담기기에 쓰기가 금지된 영역
데이터 영역
- 잠깐 썼다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터 저장 ex) 전역 변수
힙 영역
- 프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장공간
스택 영역
- 데이터가 일시적으로 저장되는 공간
- 잠깐 쓰다가 말 값들이 저장되는 공간 ex) 매개 변수, 지역 변수

프로세스 계층 구조
- 프로세스 실행 도중 (시스템 호출을 통해) 다른 프로세스 생성 가능
- 새 프로세스를 생성한 프로세스 : 부모 프로세스
- 부모 프로세스에 의해 생성된 프로세스 : 자식 프로세스
부모 프로세스와 자식 프로세스는 별개의 프로세스이므로 각기 다른 PID를 가짐

---------------------------------------------강의---------------------------------------------------------------

---------------------------------------------강의---------------------------------------------------------------
Thread
스레드는 프로세스 구성하는 실행 흐름의 단위
하나의 프로세스는 하나 이상의 스레드를 가질 수 있다.

실행 흐름이 여러 개인 프로세스 (멀티 스레드 프로세스)

스레드의 구성 요소
스레드 ID, 프로그램 카운터를 비롯한 레지스터 값, 스택 등
실행에 필요한 최소한의 정보를 가지고 있음 스레드 마다

멀티 프로세스와 멀티 스레드
동일한 작업을 수행하는 단일 프로세스 여러 개 실행 (메모리를 3개 사용)/ 자원 공유 x
vs
하나의 프로세스를 여러 스레드로 실행 (한 메모리에 실행 흐름을 3개 사용) 자원 공유 x
어떤 차이가 있을까?

- 프로세스를 fork하면 코드/데이터/힙 영역 등 모든 자원이 복제되어 저장됨
- 저장된 메모리 주소를 제외하면 모든 것이 동일한 프로세스 두 개가 통째로 메모리에 적재
- fork를 세 번 네 번하면 메모리에는 같은 프로세스가 통째로 세 개 네 개 적재
- fork 직후 같은 프로세스를 통째로 메모리에 중복 저장하지 않으면서 동시에 프로세스끼리 자원을 공유하지 않는 방법도 있다 이를 쓰기 시 복사기법이라 한다.
- 스레드들은 각기 다른 스레드 ID(별도의 실행을 위해 꼭 필요한)
- 프로그램 카운터 값을 포함한 레지스터 값, 스택을 가질 뿐 프로세스가 가지는 자원을 공유

장점
)멀티 프로세스
프로세스끼리는 자원을 공유하지 않는다 -> 남남처럼 독립적으로 실행된다
- 프로세스 간에도 자원을 주고받을 수 있다. : 프로세스 간 통신 (IPC)
- 파일을 통한 프로세스 간 통신, 공유 메모리를 통한 프로세스 간 통신

)멀티 스레드
스레드는 프로세스의 자원을 공유한다 -> 협력과 통신에 유리하다



---------------------------------------------강의---------------------------------------------------------------

2. Deadlock (조건/ 예방)
영문
동시 컴퓨팅에서 교착 상태는 자신을 포함한 다른 구성원이 메시지를 보내거나 더 일반적으로 잠금해제와 같은 조치를 취하기를 기다리기 때문에 일부 엔티티 그룹의 어떤 구성원도 진행할 수 없는 상황입니다.
---------------------------------------------강의---------------------------------------------------------------
교착 상태란 
- 일어나지 않을 사건을 기다리며 진행이 멈춰 버리는 현상

게임 - 웹브라우저 가진 자원을 기다리는중
웹브라우저 - 게임이 가진 자원을 기다리는중

해결 방법
1. 교착상태가 발생했을 때의 상황을 정확히 표현하기
 - 자원할당 그래프
 - 그리면 어떤 프로세스가 어떤 자원을 할당 받아 사용 중인지 확인 가능
 - 어떤 프로세스가 어떤 자원을 기다리고 있는지 확인 가능

그리는 방법
1 프로세스는 원 ,자원은 사각형
2 자원의 개수는 자원 사격형 내에 점으로 표현
3. 프로세스가 어떤 자원을 할당 받아 사용 중이라면 (자원에서 프로세스를 향해 화살표 표시)
4. 프로세스가 어떤 자원을 기다리고 있다면 (프로세스에서 자원으로 화살표 표시)

자원 할당 그래프가 원의 형태를 띄고 있으면 교착 상태가 발생

2. 교착상태가 일어나는 근본적인 이유 이해하기
1 상호 배제 : 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상태
2 점유와 대기 : 자원을 할당 받은 상태에서 다른 자원을 할당 받기를 기다리는 상태
3 비선점 : 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못하는 상태
4 원형 대기 : 프로세스들이 원의 형태로 자원을 대기하는 상태 - 무조건 발생하는건 아니지만 발생할수 있음

위 네 가지 조건 중 하나라도 만족하지 않으면 교착 상태가 발생하지 않음
위 네가지 조건을 모두 만족하면 교착 상태가 발생할 수 있음

교착 상태 해결 3가지 방법
예방, 회피, 검출 후 회복
교착 상태 예방 
- 애초에 교착 상태가 발생하지 않도록
- 교착 상태 발생 조건(상호 배제, 점유와 대기, 비선점, 원형 대기)중 하나를 없애버리기

교착 상태 회피
- 교착 상태를 무분별한 자원 할당으로 인해 발생했다고 간주
- 교착 상태가 발생하지 않을 만큼 조심 할당하기
- 배분할 수 있는 자원의 양을 고려하여 교착 상태가 발생하지 않을 만큼만 자원 배분
안전 순서열 : 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서
안전 상태 : 교착 상태 없이 모든 프로세스가 자원을 할당 받고 종료될 수 있는 상태
불안전 상태 : 교착 상태가 발생할 수도 있는 상태
-안전 상태에서 안전 상태로 움직이는 경우에만 자원을 할당하는 방식 - 은행원 알고리즘
- 항시 안전 상태를 유지하도록 자원을 할당하는 방식

교착 상태 검출 후 회복
- 교착 상태의 발생을 인정하고 사후에 조치하는 방식
- 프로세스가 자원을 요구하면 일단 할당, 교착 상태가 검출되면 회복
- 선점을 통한 회복, 프로세스 강제 종료를 통한 회복

선점을 통한 회복
- 교착 상태가 해결될 때까지 한 프로세스씩 자원을 몰아주는 방식
프로세스 강제 종료를 통한 회복
- 교착 샅애에 놓인 프로세스 모두 강제 종료 (작업 내역을 잃을 위험이 있음)
- 교착 상태가 해결될 때까지 한 프로세스씩 강제 종료 (오버헤드)

교착 상태 무시
타조 알고리즘

---------------------------------------------강의---------------------------------------------------------------

3. Critical section(임계구역)
블로그 - 여러 개의 쓰레드로 이루어진 시스템에서 각각의 쓰레드는 코드의 영역
1. 상호 배타 - 오류가 일어나지 않기 위해서는 데이터에 대한 업데이트는 한순간에 오직 한 쓰레드만이 진행할 수 있다는 것이다
2. 진행 - 두 쓰레드에서 누가 먼저 들어갈 것인가에 대한 결정이 유한 시간 내에 일어나야 한다는 조건이다
3. 유한대기 - 쓰레드가 임계구역에 유한 시간 내에 접근을 해야 한다는 것을 의미한다

---------------------------------------------강의---------------------------------------------------------------

임계 구역 
- 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역
- 임계 구역에 진입하고자 하면 진입한 프로세스 이외에는 대기해야 한다.
임계 구역에 동시에 접근하면 자원의 일관성이 깨질 수 있다
이를 레이스 컨디션 이라고 한다.

운영체제가 임계구역 문제를 해결하는 세 가지 원칙
1. 상호 배제 
- 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 들어올 수 없다.
2. 진행
- 임계 구역에 어떤 프로세스도 진입하지 않았다면 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
3. 유한 대기
- 한 프로세스가 임계 구역에 진입하고 싶다면 언젠가는 임계 구역에 들어올 수 있어야 한다.
(임계 구역에 들어오기 위해 무한정 대기해서는 안된다.)

---------------------------------------------강의---------------------------------------------------------------
4. Mutex vs   Semaphore
뮤텍스 - 공유된 자원의 데이터 혹은 임계영역 등에 하나의 프로세스 혹은 쓰레드가 접근하는 것을 막아줌
세마포어 - 공유된 자원의 데이터 혹은 임계영역 등에 여러 프로세스혹은 쓰레드가 접근하는 것을 막아줌

차이점
- 뮤텍스는 동기화 대상이 오직 하나일떄 사용하며, 세마포어는 동기화 대상이 하나 이상일 때 사용
- 뮤텍스는 자원을 소유할 수 있고, 책임을 가지는 반면 세마포어는 자원 소유가 불가

---------------------------------------------강의---------------------------------------------------------------

뮤텍스 
- 상호 배제를 위한 동기화 도구(자물쇠 역할)

세마포
- 좀 더 일반화된 방식의 동기화 도구
- 공유 자원이 여러 개 있는 경우에도 적용 가능
임계 구역 앞에서 멈춤 신호를 받으면 잠시 기다리기
임계 구역 앞에서 가도 좋다는 신호를 받으면 임계 구역 진입

---------------------------------------------강의---------------------------------------------------------------

5. Concurrency vs Paralleism

parallenlism은 여러 코어에서 여러 작업을 동시에 수행하는 것입니다.
코어가 하나밖에 없다면 병력적으로 프로그램을 실행할 수 없습니다.

concurrency는 빠르게 전환하며 여러 작업을 수행하여 동시에 여러 작업이 실행되는 것처럼 보이는 것입니다. 
코어에서도 여러 작업을 concurrent하게 실행할 수 있고 작업 간에는 문맥 교환이 일어납니다

동시성
- 동시에 실행되는 것처럼 보이는 것
ex) 한 사람이 여러 일을 조금씩 아주 빨리 처리하는 방식
- 싱글 코어에서 멀티 스레드

병렬성
- 실제로 동시에 여러 작업이 처리되는 것
ex) 여러 사람이 여러 일을 나눠서 처리하는 방식
- 멀티 코어에서 멀티 스레드

